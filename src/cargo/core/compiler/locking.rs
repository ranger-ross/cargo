//! This module handles the locking logic during compilation.
//!
//! The locking scheme is based on build unit level locking.
//! Each build unit consists of a partial and full lock used to represent multiple lock states.
//!
//! | State                  | `partial.lock` | `full.lock`  |
//! |------------------------|----------------|--------------|
//! | Unlocked               | `unlocked`     | `unlocked`   |
//! | Building Exclusive     | `exclusive`    | `exclusive`  |
//! | Building Non-Exclusive | `shared`       | `exclusive`  |
//! | Shared Partial         | `shared`       | `unlocked`   |
//! | Shared Full            | `shared`       | `shared`     |
//!
//! Generally a build unit will full the following flow:
//! 1. Acquire a "building exclusive" lock for the current build unit.
//! 2. Acquire "shared" locks on all dependency build units.
//! 3. Begin building with rustc
//! 4. If we are building a library, downgrade to a "building non-exclusive" lock when the `.rmeta` has been generated.
//! 5. Once complete release all locks.
//!
//! Most build units only require metadata (.rmeta) from dependencies, so they can begin building
//! once the dependency units have produced the .rmeta. These units take a "shared partial" lock
//! which can be taken while the dependency still holds the "build non-exclusive" lock.
//!
//! Note that some build unit types like bin and proc-macros require the full dependency build
//! (.rlib). For these unit types they must take a "shared full" lock on dependency units which will
//! block until the dependency unit is fully built.
//!
//! The primary reason for the complexity here it to enable fine grain locking while also allowing pipelined builds.
//!
//! [`CompilationLock`] is the primary interface for locking.

use std::{
    collections::{HashMap, HashSet},
    fs::{File, OpenOptions},
    path::{Path, PathBuf},
    sync::{Arc, Condvar, LazyLock, Mutex},
};

use anyhow::{Context, anyhow};
use itertools::Itertools;
use tracing::{debug, instrument, trace, warn};

use crate::{
    CargoResult,
    core::{
        Workspace,
        compiler::{BuildContext, BuildRunner, Unit, layout::BuildUnitLockLocation},
    },
    util::{flock::is_on_nfs_mount, rlimit},
};

/// The strategy to use for locking during a build.
///
/// A strategy is made up of multiple locking modes for different directories.
#[derive(Debug)]
pub struct LockingStrategy {
    /// The locking mode for the artifact-dir
    artifact_dir: LockingMode,
    /// The locking mode for the build-dir
    ///
    /// Will be `None` when artifact_dir and build_dir are the same directory.
    build_dir: Option<LockingMode>,
}

/// Determines if we have enough resources to safely use fine grain locking.
/// This function will raises the number of max number file descriptors the current process
/// can have open at once to make sure we are able to compile without running out of fds.
///
/// If we cannot acquire a safe max number of file descriptors, we fallback to coarse grain
/// locking.
pub fn determine_locking_mode(bcx: &BuildContext<'_, '_>) -> CargoResult<LockingMode> {
    let total_units = bcx.unit_graph.keys().len() as u64;

    // This is a bit arbitrary but if we do not have at least 10 times the remaining file
    // descriptors than total build units there is a chance we could hit the limit.
    // This is a fairly conservative estimate to make sure we don't hit max fd errors.
    let safe_threshold = total_units * 10;

    let Ok(mut limit) = rlimit::get_max_file_descriptors() else {
        return Ok(LockingMode::Coarse);
    };

    if limit.soft_limit >= safe_threshold {
        // The limit is higher or equal to what we deemed safe, so
        // there is no need to raise the limit.
        return Ok(LockingMode::Fine);
    }

    let display_fd_warning = || -> CargoResult<()> {
        bcx.gctx.shell().verbose(|shell| shell.warn("ulimit was to low to safely enable fine grain locking, falling back to coarse grain locking"))
    };

    if limit.hard_limit < safe_threshold {
        // The max we could raise the limit to is still not enough to safely compile.
        display_fd_warning()?;
        return Ok(LockingMode::Coarse);
    }

    limit.soft_limit = safe_threshold;

    debug!("raising fd limit to {safe_threshold}");
    if let Err(err) = rlimit::set_max_file_descriptors(limit) {
        warn!("failed to raise max fds: {err}");
        display_fd_warning()?;
        return Ok(LockingMode::Coarse);
    }

    return Ok(LockingMode::Fine);
}

impl LockingStrategy {
    /// Determines the locking strategy the current environment can support.
    pub fn determine_locking_strategy(
        ws: &Workspace<'_>,
        bcx: Option<&BuildContext<'_, '_>>,
    ) -> CargoResult<Self> {
        let artifact_dir_locking_mode = match is_on_nfs_mount(ws.target_dir().as_path_unlocked()) {
            true => {
                debug!("NFS detected. Disabling file system locking for artifact-dir");
                LockingMode::Disabled
            }
            false => LockingMode::Coarse,
        };
        let build_dir_locking_mode = if ws.target_dir() == ws.build_dir() {
            None
        } else {
            let locking_mode = if is_on_nfs_mount(ws.build_dir().as_path_unlocked()) {
                debug!("NFS detected. Disabling file system locking for build-dir");
                LockingMode::Disabled
            } else {
                if let Some(bcx) = bcx {
                    Self::determine_build_dir_locking_mode(bcx)?
                } else {
                    LockingMode::Coarse
                }
            };

            Some(locking_mode)
        };
        Ok(Self {
            artifact_dir: artifact_dir_locking_mode,
            build_dir: build_dir_locking_mode,
        })
    }

    fn determine_build_dir_locking_mode(bcx: &BuildContext<'_, '_>) -> CargoResult<LockingMode> {
        if bcx.ws.gctx().cli_unstable().fine_grain_locking {
            return Ok(LockingMode::Fine);
        }

        let total_units = bcx.unit_graph.keys().len() as u64;

        // This is a bit arbitrary but if we do not have at least 10 times the remaining file
        // descriptors than total build units there is a chance we could hit the limit.
        // This is a fairly conservative estimate to make sure we don't hit max fd errors.
        let safe_threshold = total_units * 10;

        let Ok(mut limit) = rlimit::get_max_file_descriptors() else {
            return Ok(LockingMode::Coarse);
        };

        if limit.soft_limit >= safe_threshold {
            // The limit is higher or equal to what we deemed safe, so
            // there is no need to raise the limit.
            return Ok(LockingMode::Fine);
        }

        let display_fd_warning = || -> CargoResult<()> {
            bcx.gctx.shell().verbose(|shell| shell.warn("ulimit was to low to safely enable fine grain locking, falling back to coarse grain locking"))
        };

        if limit.hard_limit < safe_threshold {
            // The max we could raise the limit to is still not enough to safely compile.
            display_fd_warning()?;
            return Ok(LockingMode::Coarse);
        }

        limit.soft_limit = safe_threshold;

        debug!("raising fd limit to {safe_threshold}");
        if let Err(err) = rlimit::set_max_file_descriptors(limit) {
            warn!("failed to raise max fds: {err}");
            display_fd_warning()?;
            return Ok(LockingMode::Coarse);
        }

        return Ok(LockingMode::Fine);
    }

    pub fn artifact_dir(&self) -> &LockingMode {
        &self.artifact_dir
    }

    pub fn build_dir(&self) -> &LockingMode {
        self.build_dir.as_ref().unwrap_or(&self.artifact_dir)
    }

    /// If the artifact_dir and build_dir are the same directory.
    pub fn is_unified_output_dir(&self) -> bool {
        self.build_dir.is_none()
    }
}

/// The locking mode that will be used for output directories.
#[derive(Debug)]
pub enum LockingMode {
    /// Completely disables locking (used for filesystems that do not support locking)
    Disabled,
    /// Fine grain locking (Build unit level)
    Fine,
    /// Coarse grain locking (Profile level)
    Coarse,
}

/// The type of lock to take when taking a shared lock.
/// See the module documentation for more information about shared lock types.
#[derive(Debug)]
pub enum SharedLockType {
    /// A shared lock that might still be compiling a .rlib
    Partial,
    /// A shared lock that is guaranteed to not be compiling
    Full,
}

/// A lock for compiling a build unit.
///
/// Internally this lock is made up of many [`UnitLock`]s for the unit and it's dependencies.
pub struct CompilationLock {
    /// The path to the lock file of the unit to compile
    unit: UnitLock,
    /// The paths to lock files of the unit's dependencies
    dependency_units: Vec<UnitLock>,
}

impl CompilationLock {
    pub fn new(build_runner: &BuildRunner<'_, '_>, unit: &Unit) -> Self {
        let unit_lock = UnitLock::new(build_runner.files().build_unit_lock(unit));

        let dependency_units = all_dependency_units(build_runner, unit)
            .into_iter()
            .map(|unit| UnitLock::new(build_runner.files().build_unit_lock(&unit)))
            .collect_vec();

        Self {
            unit: unit_lock,
            dependency_units,
        }
    }

    #[instrument(skip(self))]
    pub fn lock(&mut self, ty: &SharedLockType) -> CargoResult<()> {
        self.unit.lock_exclusive()?;

        for d in self.dependency_units.iter_mut() {
            d.lock_shared(ty)?;
        }

        trace!("acquired lock: {:?}", self.unit.partial.parent());

        Ok(())
    }

    pub fn rmeta_produced(&mut self) -> CargoResult<()> {
        trace!("downgrading lock: {:?}", self.unit.partial.parent());

        // Downgrade the lock on the unit we are building so that we can unblock other units to
        // compile. We do not need to downgrade our dependency locks since they should always be a
        // shared lock.
        self.unit.downgrade()?;

        Ok(())
    }
}

/// A lock for a single build unit.
struct UnitLock {
    partial: PathBuf,
    full: PathBuf,
    guard: Option<UnitLockGuard>,
}

struct UnitLockGuard {
    partial: Arc<RcFileLock>,
    full: Option<Arc<RcFileLock>>,
}

impl Drop for UnitLockGuard {
    fn drop(&mut self) {
        self.partial.unlock().unwrap();
        if let Some(full) = &self.full {
            full.unlock().unwrap();
        }
    }
}

impl UnitLock {
    pub fn new(location: BuildUnitLockLocation) -> Self {
        Self {
            partial: location.partial,
            full: location.full,
            guard: None,
        }
    }

    pub fn lock_exclusive(&mut self) -> CargoResult<()> {
        assert!(self.guard.is_none());

        let partial = FileLockInterner::get_or_create_lock(&self.partial)?;
        partial.lock()?;

        let full = FileLockInterner::get_or_create_lock(&self.full)?;
        full.lock()?;

        self.guard = Some(UnitLockGuard {
            partial,
            full: Some(full),
        });
        Ok(())
    }

    pub fn lock_shared(&mut self, ty: &SharedLockType) -> CargoResult<()> {
        assert!(self.guard.is_none());

        let partial = FileLockInterner::get_or_create_lock(&self.partial)?;
        partial.lock_shared()?;

        let full = if matches!(ty, SharedLockType::Full) {
            let full_lock = FileLockInterner::get_or_create_lock(&self.full)?;
            full_lock.lock_shared()?;
            Some(full_lock)
        } else {
            None
        };

        self.guard = Some(UnitLockGuard { partial, full });
        Ok(())
    }

    pub fn downgrade(&mut self) -> CargoResult<()> {
        let guard = self
            .guard
            .as_ref()
            .context("guard was None while calling downgrade")?;
        guard.partial.downgrade()?;

        Ok(())
    }
}

fn open_file<T: AsRef<Path>>(f: T) -> CargoResult<File> {
    Ok(OpenOptions::new()
        .read(true)
        .create(true)
        .write(true)
        .append(true)
        .open(f)?)
}

fn all_dependency_units<'a>(
    build_runner: &'a BuildRunner<'a, '_>,
    unit: &Unit,
) -> HashSet<&'a Unit> {
    fn inner<'a>(
        build_runner: &'a BuildRunner<'a, '_>,
        unit: &Unit,
        results: &mut HashSet<&'a Unit>,
    ) {
        for dep in build_runner.unit_deps(unit) {
            if results.insert(&dep.unit) {
                inner(&build_runner, &dep.unit, results);
            }
        }
    }

    let mut results = HashSet::new();
    inner(build_runner, unit, &mut results);
    return results;
}

/// An interner to manage [`RcFileLock`]s to make sharing across compilation jobs easier.
pub struct FileLockInterner {
    locks: Mutex<HashMap<PathBuf, Arc<RcFileLock>>>,
}

impl FileLockInterner {
    pub fn new() -> Self {
        Self {
            locks: Mutex::new(HashMap::new()),
        }
    }

    pub fn get_or_create_lock(path: &Path) -> CargoResult<Arc<RcFileLock>> {
        static GLOBAL: LazyLock<FileLockInterner> = LazyLock::new(FileLockInterner::new);

        let mut locks = GLOBAL
            .locks
            .lock()
            .map_err(|_| anyhow!("lock was poisoned"))?;

        if let Some(lock) = locks.get(path) {
            return Ok(Arc::clone(lock));
        }

        let file = open_file(&path)?;

        let lock = Arc::new(RcFileLock {
            inner: Mutex::new(RcFileLockInner {
                file,
                share_count: 0,
                exclusive: false,
            }),
            condvar: Condvar::new(),
        });

        locks.insert(path.to_path_buf(), Arc::clone(&lock));

        return Ok(lock);
    }
}

/// A reference counted file lock.
///
/// This lock is designed to reduce file descriptors by sharing a single file descriptor for a
/// given lock when the lock is shared. The motivation for this is to avoid hitting file descriptor
/// limits when fine grain locking is enabled.
pub struct RcFileLock {
    inner: Mutex<RcFileLockInner>,
    condvar: Condvar,
}

struct RcFileLockInner {
    file: File,
    exclusive: bool,
    share_count: u32,
}

impl RcFileLock {
    pub fn lock(&self) -> CargoResult<()> {
        let mut inner = self
            .inner
            .lock()
            .map_err(|_| anyhow!("lock was poisoned"))?;

        while inner.exclusive || inner.share_count > 0 {
            inner = self
                .condvar
                .wait(inner)
                .map_err(|_| anyhow!("lock was poisoned"))?;
        }

        inner.file.lock()?;
        inner.exclusive = true;

        Ok(())
    }

    pub fn lock_shared(&self) -> CargoResult<()> {
        let mut inner = self
            .inner
            .lock()
            .map_err(|_| anyhow!("lock was poisoned"))?;

        while inner.exclusive {
            inner = self
                .condvar
                .wait(inner)
                .map_err(|_| anyhow!("lock was poisoned"))?;
        }

        if inner.share_count == 0 {
            inner.file.lock_shared()?;
            inner.share_count = 1;
        } else {
            inner.share_count += 1;
        }

        Ok(())
    }

    pub fn unlock(&self) -> CargoResult<()> {
        let mut inner = self
            .inner
            .lock()
            .map_err(|_| anyhow!("lock was poisoned"))?;

        if inner.exclusive {
            assert!(inner.share_count == 0);
            inner.file.unlock()?;
            self.condvar.notify_all();
            inner.exclusive = false;
        } else {
            if inner.share_count > 1 {
                inner.share_count -= 1;
            } else {
                inner.file.unlock()?;
                inner.share_count = 0;
                self.condvar.notify_all();
            }
        }

        Ok(())
    }

    pub fn downgrade(&self) -> CargoResult<()> {
        let mut inner = self
            .inner
            .lock()
            .map_err(|_| anyhow!("lock was poisoned"))?;

        assert!(inner.exclusive);
        assert!(inner.share_count == 0);

        // NOTE:
        // > Subsequent flock() calls on an already locked file will convert an existing lock to the new lock mode.
        // https://man7.org/linux/man-pages/man2/flock.2.html
        //
        // However, the `std::file::File::lock/lock_shared` is allowed to change this in the
        // future. So its probably up to us if we are okay with using this or if we want to use a
        // different interface to flock.
        inner.file.lock_shared()?;

        inner.exclusive = false;
        inner.share_count = 1;

        Ok(())
    }
}

pub struct BuildCacheLock {
    _file: File,
}

impl BuildCacheLock {
    pub fn write(path: impl AsRef<Path>) -> CargoResult<Self> {
        let path = path.as_ref().join("partial.lock"); // TODO: Move to layout

        let file = open_file(&path)?;

        file.lock()?;

        Ok(Self { _file: file })
    }

    pub fn shared(path: impl AsRef<Path>) -> CargoResult<Self> {
        let path = path.as_ref().join("partial.lock"); // TODO: Move to layout

        let file = open_file(&path)?;

        file.lock_shared()?;

        Ok(Self { _file: file })
    }
}
